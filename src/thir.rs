use apint::{ApInt, Int, UInt};
use lsp_types::Range;
use num_bigint::BigInt;
use num_rational::BigRational;

use crate::{builtin::Builtin, values::Value};

#[derive(Clone, Debug, PartialEq)]
pub struct Augmented<T> {
    pub range: Range,
    pub val: T,
}

#[derive(Clone, Debug)]
pub enum PatExpr {
    Error,
    Ignore,
    Identifier(usize),
    StructLiteral(Vec<(Augmented<String>, Augmented<PatExpr>)>),
    New {
        nom_id: usize,
        pat: Box<Augmented<PatExpr>>,
    },
    Literal(Value),
}

impl std::default::Default for PatExpr {
    fn default() -> Self {
        PatExpr::Error
    }
}

#[derive(Clone, Debug)]
pub enum PlaceExpr {
    Error,
    Var {
        debruijn: usize,
        global: usize,
    },
    FieldAccess {
        root: Box<Augmented<PlaceExpr>>,
        field: String,
    },
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord)]
pub enum UseKind {
    Borrow,
    MutBorrow,
    Move,
}

#[derive(Clone, Debug)]
pub enum ValExpr {
    // An error when parsing
    Error,
    Int {
        value: Int,
    },
    Nat {
        value: UInt,
    },
    Bool {
        value: bool,
    },
    Float {
        value: BigRational,
    },
    String(Vec<u8>),
    Use(Box<Augmented<PlaceExpr>>, UseKind),
    // Builtin
    Builtin {
        builtin: Builtin,
        level: usize,
    },
    // Function
    Lam {
        // a function body cannot directly access an external variable
        // everything must come from the captured_vars struct,
        // a struct that is generated by inspecting the body
        // 1. A take in the body:
        //    a. take becomes take
        //    b. mutborrow becomes mutborrow
        //    c. borrow becomes borrow
        // 2. A mutborrow in the body
        //    a. mutborrow becomes reborrow
        //    b. borrow becomes reborrow + downcast
        // 3. A borrow in the body:
        //    a. borrow becomes copy
        captures: Vec<(Augmented<PatExpr>, Augmented<ValExpr>)>,
        params: Vec<Augmented<PatExpr>>,
        body: Box<Augmented<ValExpr>>,
    },
    // Constructs a new compound type
    StructLiteral(Vec<(Augmented<String>, Augmented<ValExpr>)>),
    // Creates a new instance of a nominal type
    New {
        ty: Box<Augmented<ValExpr>>,
        val: Box<Augmented<ValExpr>>,
    },
    // Matches an expression to the first matching pattern and destructures it
    CaseOf {
        expr: Box<Augmented<ValExpr>>,
        cases: Vec<(Augmented<PatExpr>, Augmented<ValExpr>)>,
    },
    // Block
    Block {
        statements: Vec<Augmented<BlockStatement>>,
        last_expr: Box<Augmented<ValExpr>>,
    },
    // Inline array
    ArrayLiteral(Vec<Augmented<ValExpr>>),
    // FieldAccess
    FieldAccess {
        root: Box<Augmented<ValExpr>>,
        field: String,
    },
    // short circuiting operators
    And {
        left: Box<Augmented<ValExpr>>,
        right: Box<Augmented<ValExpr>>,
    },
    Or {
        left: Box<Augmented<ValExpr>>,
        right: Box<Augmented<ValExpr>>,
    },
    // Function application
    App {
        fun: Box<Augmented<ValExpr>>,
        args: Vec<Augmented<ValExpr>>,
    },
    // type of a function
    PiTy {
        // works exactly like a function
        captures: Vec<(Augmented<PatExpr>, Augmented<ValExpr>)>,
        params: Vec<Augmented<PatExpr>>,
        // this is the return type
        dep_ty: Box<Augmented<ValExpr>>,
    },
    // struct and enum
    Struct(Vec<(Augmented<String>, Augmented<ValExpr>)>),
    Enum(Vec<(Augmented<String>, Augmented<ValExpr>)>),
    Union(Vec<(Augmented<String>, Augmented<ValExpr>)>),
    Extern {
        name: Vec<u8>,
        ty: Box<Augmented<ValExpr>>,
    },
    Loop {
        body: Box<Augmented<ValExpr>>,
    },
    Label {
        label: usize,
        value: Box<Augmented<ValExpr>>,
    },
    Ret {
        label: usize,
        value: Box<Augmented<ValExpr>>,
    },
}

impl std::default::Default for ValExpr {
    fn default() -> Self {
        ValExpr::Error
    }
}

#[derive(Clone, Debug)]
pub enum BlockStatement {
    Error,
    NoOp,
    Let {
        pat: Box<Augmented<PatExpr>>,
        value: Box<Augmented<ValExpr>>,
    },
    Do(Box<Augmented<ValExpr>>),
}

#[derive(Clone, Debug)]
pub enum FileStatement {
    Error,
    Let {
        pat: Box<Augmented<PatExpr>>,
        value: Box<Augmented<ValExpr>>,
    },
}
